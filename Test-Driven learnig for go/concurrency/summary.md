### 总结



#### * *goroutines* 是 Go 的基本并发单元，它让我们可以同时检查多个网站。
#### * *anonymous functions*（匿名函数），我们用它来启动每个检查网站的并发进程。
#### * *channels* 用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件） 的问题。
#### * 当我们迭代 urls 时，不是直接写入 map，而是使用 send statement 将每个调用 wc 的 result 结构体发送到 resultChannel。这使用 <- 操作符，channel 放在左边，值放在右边：
  ```// send statement
  resultChannel <- result{u, wc(u)}
  ```
* 下一个 for 循环为每个 url 迭代一次。 我们在内部使用 receive expression，它将从通道接收到的值分配给变量。这也使用 <- 操作符，但现在两个操作数颠倒过来：现在 channel 在右边，我们指定的变量在左边：
  ```// receive expression
  result := <-resultChannel
  ```
* 然后我们使用接收到的 result 更新 map。
* 通过将结果发送到通道，我们可以控制每次写入 results map 的时间，确保每次写入一个结果。虽然 wc 的每个调用都发送给结果通道，但是它们在其自己的进程内并行发生，因为我们将结果通道中的值与接收表达式一起逐个处理一个结果。
* 我们已经将想要加快速度的那部分代码并行化，同时确保不能并发的部分仍然是线性处理。我们使用 channel 在多个进程间通信。
#### * *the race detector*（竞争探测器） 帮助我们调试并发代码的问题。
* 当软件的输出取决于事件发生的时间和顺序时，因为我们无法控制，bug 就会出现。因为我们无法准确控制每个 goroutine 写入结果 map 的时间，两个 goroutines 同一时间写入时程序将非常脆弱。
  Go 可以帮助我们通过其内置的 race detector 来发现竞争条件。要启用此功能，请使用 race 标志运行测试：go test -race。


### 使程序加快
* 一种构建软件的敏捷方法，常常被错误地归属于 Kent Beck，即：
*让它运作，使它正确，使它快速*

* 「运作」是通过测试，「正确」是重构代码，而「快速」是优化代码以使其快速运行。一旦我们使程序可以正确运行，我们能做的就只有使它快速。很幸运，我们得到的代码已经被证明是可以运作的，并且不需要重构。在另外两个步骤执行之前，我们绝不应该试图「使它快速」，因为

* *过早的优化是万恶之源*—— Donald Knuth