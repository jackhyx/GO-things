### 区别在哪
#### 代码块的分组声明
* 使用包含关键字 var 的声明语法时，和其他 package、import、const、type、var 等关键字一样，是可以进行分组的代码块声明的。
* 例如：
```
var (
    i       int
    u, v, s = 1.0, 2.0, "脑子进煎鱼了"
)
```
* 而短声明，是不支持的。
#### 变量的初始值指定:使用标准的变量定义时，我们可以只声明，不主动地定义该变量的初始值（缺省会给零值）。

* 例如：
```
var (
    i    int
    s    string
)
```
* 而短声明则不行，必须要在程序中主动地去对变量定义一个值。
```
s := "脑子进煎鱼了"
```
* 此处即使是定义的空字符串，那也属于是用户侧主动定义的，而非缺省的零值。
#### 局部变量，区分作用域
* 在编写程序时，我们经常会有一些局部变量声明，且作用域是有限的。 可以看看自己的代码，这种时候，我们都会采取短声明的方式。
```
for idx, value := range array {
    // Do something with index and value
}

if num := runtime.NumCPU(); num > 1 {
    fmt.Println("Multicore CPU, cores:", num)
}
```
* 短声明在这类场景下有明确的优势，标准的变量声明在这类场景不讨好。
####重新声明变量
* 在 Go 语言规范中有明确提到，短变量声明是可以重新声明变量的，这是一个高频重新声明的覆盖动作。
```
var name = "煎鱼.txt"

fi, err := os.Stat(name)
if err != nil {
    log.Fatal(err)
}

data, err := ioutil.ReadFile(name)
if err != nil {
    log.Fatal(err)
}
...
```
#### 上述代码中，err 变量就是不断地被反复定义。在 if err != nil 猖狂的现在，短变量在此处的优势，简直是大杀器了。
#### 总结

* **代码块的分组声明**。
* **变量的初始值指定**。
* **局部变量，区分作用域**。
* **重新声明变量**。
