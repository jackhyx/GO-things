### defer
#### defer是Go语言中提供的关键字，可以注册多个延迟调用，，这些调用可以先进后出的顺序在函数返回前被执行。使用defer可以方便我们的开发，但同时要注意它的副作用，下面对几个要注意的点进行介绍讲解。

#### defer和函数返回值
* defer中如果引用了函数的返回值，则会因引用形式不同导致不同的结果，这些结果会造成很大问题困扰，下面我们先看一下示例：
```
package main
import "fmt"
func func1()  (r int){
defer func(){
r++
}()
return 0
}
func func2()  (r int){
t := 5
defer func() {
t = t+5
}()
return t
}
func func3() (r int){
defer func(r int) {
r = r+5
}(r)
return 1
}
func main(){
fmt.Println("func1=",func1())
fmt.Println("func2=",func2())
fmt.Println("func3=",func3())
}
//运行结果
1
5
1
```
* 根据结果我们进行分析，func1、func2、func3这三个函数的共同点就是带命名返回值的函数，返回值都是变量r。我们知道函数调用方负责开辟栈空间，包括形参和返回值的空间。有名的函数返回值相当于函数的局部变量，被初始化为类型的零值。
#### 所以我们可以分析func1函数如下：

* r是函数的有名返回值，分配在栈上，其地址又被称为返回值所在栈区。首先r被初始化为0.
* "return 0"会复制0到返回值栈区，返回值r被赋值为0。 
* 执行defer语句，由于匿名函数对返回值r是闭包引用，所以r++执行后，函数返回值被修改为1。 
* defer语句执行完后RET返回，此时函数的返回值仍然为1。


#### 同样道理分析func2的逻辑：

* 返回值r被初始化为0。
* 引入局部变量t，并初始化为5。
* 复制t的值5到返回值r所在的栈区
* defer语句后面的匿名函数是对局部变量t的闭包引用，t的值被设置为10.
* 函数返回，此时函数返回值栈区上的值仍然是5.


#### 最后我们分析func3的逻辑：
* 返回值r被初始化为0.
* 复制1到函数返回值r所在的栈区
* 执行defer，defer后匿名函数使用的是传参数调用，在注册defer函数是将函数返回值r作为实参传进去，由于函数调用的是值拷贝，所以defer函数执行后只是形参值变为5，对实参没有任何影响。
* 函数返回，此时函数返回值栈区上的值是1。


* 通过对以上三个函数的分析，我们可以对带defer的函数返回整体进行总结，有如下三个步骤：

* 执行return的值拷贝，将return语句返回的值复制到函数返回值栈区（如果只有一个return，不带任何变量或值，则此步骤不做任何动作）

* 执行defer语句，多个defer按照FILO顺序执行。

* 执行调整RET指令。
* 上面的例子是在defer中修改函数返回值不是一种明智的编程方法，所以在实际编程中应尽可能避免此种情况。还有一种方法可以解决这个问题，在定义函数时使用不带返回值名的格式。通过这种方式，defer就不能引用返回值的栈区，也就避免了返回值被修改的问题。
