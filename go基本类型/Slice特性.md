### 切片-slice

#### 从数组或切片生成新的切片拥有如下特性：
* 取出的元素数量为：结束位置 - 开始位置；
* 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取； 
* 当缺省开始位置时，表示从连续区域开头到结束位置； 
* 当缺省结束位置时，表示从开始位置到整个连续区域末尾； 
* 两者同时缺省时，与切片本身等效； a[:]
* 两者同时为 0 时，等效于空切片，一般用于切片复位。 a[0:0]
  var numListEmpty = []int{} // numListEmpty 已经被分配了内存，只是还没有元素。
  numListEmpty == nil // false
#### 使用 make() 函数构造切片
如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：
  make( []Type, size, cap )
* 其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。
* 使用 make() 函数生成的切片一定发生了内存分配操作
* 给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。

#### 根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。
* 切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域， 
* 切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。

* 切片赋值会导致底层数据的变化，从而影响其它的切片值
```

func main() {
	var c = [4]int{1,2,3,4}
	var Aslice = c[0:2]
	Aslice = append(Aslice,5)
	fmt.Println(c) //[1 2 5 4] 改变了底层数组
	fmt.Println(Aslice) //[1 2 5]
	Bslice := append(Aslice,5,5,5) //扩容超过底层数组的容量
	fmt.Println(c) //[1 2 5 4]
	fmt.Println(Bslice) //[1 2 5 5 5 5] //指向了新的数组
}	

```
### 切片是引用类型
```
func main() {
	//a是一个数组，注意数组是一个固定长度的，初始化时候必须要指定长度，不指定长度的话就是切片了
	a := [3]int{1, 2, 3}
	//b是数组，是a的一份拷贝
	b := a
	//c是切片，是引用类型，底层数组是a
	c := a[:]
	for i := 0; i < len(a); i++ {
	a[i] = a[i] + 1
	}
     //改变a的值后，b是a的拷贝，b不变，c是引用，c的值改变
	fmt.Println(a) //[2,3,4]
	fmt.Println(b) //[1 2 3]
	fmt.Println(c) //[2,3,4]
}

```
* 在函数传参中是值传递，所以会copy一份原始的切片，但是指向底层数组的指针不变，如果我们在函数中对这个copy过的切片操作（非赋值），例如重新进行切片操作，这样不会影响原切片，但是如果我们在此进行例如a[0]=1此类的操作，会修改原数组
* 对于slice来说来说，在Go语言当中，切片类型是不可比较的
### 切片，数组可进行赋值操作
```
func main() {
	//切片
	var a = make([]string,10)
	//a[0] = 1 //赋值其他类型均报错
	a[0] = "grape"
                    
	//数组
	var a = [3]int{}
	a[0] =1
	a[1] = "strin" //赋值其他类型均报错
}   
```
* 基本规则：对于每个赋值一定要类型一致，和其他一样，不同的类型不可以进行赋值操作。当然，interface{}例外
### 切片，数组和字符串的循环
* 切片数组字符串循环代码示例：
```
func main() {
	var a = [3]int{1,2,3}
	for i,v := range(a) { 
		fmt.Println(i,v)  // 0 1   1 2  2 3
     }
        
	var b = []int{3,4,5}
	for i,v := range(b) {
		fmt.Println(i,v)  //0 3  1 4  2 5
	}
        
	var c = "hello world"
	hello := c[:5]  
	world := c[7:]
	fmt.Println(hello, world)  //hello  world
	for i,v := range(c) {
		fmt.Println(i,string(v))  // 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd',
		fmt.Println(i,v)  //0 104 1 101 2 108 3 108 4 111 5 32 6 19990 9 30028 //range会转化底层byte为rune
	}
}

```
### 切片类型强转
```
func main() {
	var a = []float64{4, 2, 5, 7, 2, 1, 88, 1}
	//var c = ([]int)(a) //报错
	var b = make([]int, 8)
	for i,v := range a {
		b[i] = int(v)// 对每个元素分别进行转换
	}
	fmt.Println(b)
}
```
#### 切片复制
Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。

copy() 函数的使用格式如下：
copy( destSlice, srcSlice []T) int

其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。
