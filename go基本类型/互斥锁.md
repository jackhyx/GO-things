sync 包下的mutex就是互斥锁，其提供了三个公开方法：调用Lock()获得锁，调用Unlock()释放锁，在Go1.18新提供了TryLock()方法可以非阻塞式的取锁操作：

Lock()：调用Lock方法进行加锁操作，使用时应注意在同一个goroutine中必须在锁释放时才能再次上锁，否则会导致程序panic。

Unlock()：调用UnLock方法进行解锁操作，使用时应注意未加锁的时候释放锁会引起程序panic，已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁。

tryLock()：调用TryLock方法尝试获取锁，当锁被其他 goroutine 占有，或者当前锁正处于饥饿模式，它将立即返回 false，当锁可用时尝试获取锁，获取失败不会自旋/阻塞，也会立即返回false；


#### 互斥锁有两种模式：正常模式、饥饿模式
* 饥饿模式的出现是为了优化正常模式下刚被唤起的goroutine与新创建的goroutine竞争时长时间获取不到锁，
* 在Go1.9时引入饥饿模式，如果一个goroutine获取锁失败超过1ms,则会将Mutex切换为饥饿模式，
* 如果一个goroutine获得了锁，并且他在等待队列队尾 或者 他等待小于1ms，则会将Mutex的模式切换回正常模式

#### 加锁的过程：

* 锁处于完全空闲状态，通过CAS直接加锁

* 当锁处于正常模式、加锁状态下，并且符合自旋条件，则会尝试最多4次的自旋

* 若当前goroutine不满足自旋条件时，计算当前goroutine的锁期望状态

* 尝试使用CAS更新锁状态，若更新锁状态成功判断当前goroutine是否可以获取到锁，获取到锁直接退出即可，若不同获取到锁子则陷入睡眠，等待被唤醒

* goroutine被唤醒后，如果锁处于饥饿模式，则直接拿到锁，否则重置自旋次数、标志唤醒位，重新走for循环自旋、获取锁逻辑；

#### 解锁的过程

* 原子操作mutexLocked，如果锁为完全空闲状态，直接解锁成功

* 如果锁不是完全空闲状态，，那么进入unlockedslow逻辑

* 如果解锁一个未上锁的锁直接panic，因为没加锁mutexLocked的值为0，解锁时进行mutexLocked - 1操作，这个操作会让整个互斥锁魂村，所以需要有这个判断

* 如果锁处于饥饿模式直接唤醒等待队列队头的waiter

* 如果锁处于正常模式下，没有等待的goroutine可以直接退出，如果锁已经处于锁定状态、唤醒状态、饥饿模式则可以直接退出，
* 因为已经有被唤醒的 goroutine 获得了锁.

* 使用互斥锁时切记拷贝Mutex，因为拷贝Mutex时会连带状态一起拷贝，因为Lock时只有锁在完全空闲时才会获取锁成功，拷贝时连带状态一起拷贝后，会造成死锁

#### TryLock的实现逻辑很简单，主要判断当前锁处于加锁状态、饥饿模式就会直接获取锁失败，尝试获取锁失败直接返回；
