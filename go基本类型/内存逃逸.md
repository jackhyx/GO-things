#### 什么是内存逃逸
* 在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，
* 在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从"栈"上逃逸到"堆"上的现象就成为内存逃逸。

什么是逃逸分析
上面我们知道了什么是内存逃逸，下面我们就来看一看什么是逃逸分析？

上文我们说到C语言使用malloc在堆上动态分配内存后，还需要手动调用free释放内存，如果不释放就会造成内存泄漏的风险。在Go语言中堆内存的分配与释放完全不需要我们去管了，Go语言引入了GC机制，GC机制会对位于堆上的对象进行自动管理，当某个对象不可达时(即没有其对象引用它时)，他将会被回收并被重用。虽然引入GC可以让开发人员降低对内存管理的心智负担，但是GC也会给程序带来性能损耗，当堆内存中有大量待扫描的堆内存对象时，将会给GC带来过大的压力，虽然Go语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率，但是如果我们的程序仍在堆上分配了大量内存，依赖会对GC造成不可忽视的压力。因此为了减少GC造成的压力，Go语言引入了逃逸分析，也就是想法设法尽量减少在堆上的内存分配，可以在栈中分配的变量尽量留在栈中。

小结逃逸分析：

逃逸分析就是指程序在编译阶段根据代码中的数据流，对代码中哪些变量需要在栈中分配，哪些变量需要在堆上分配进行静态分析的方法。堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。所以逃逸分析更做到更好内存分配，提高程序的运行速度。

* 逃逸分析在编译阶段确定哪些变量可以分配在栈中，哪些变量分配在堆上
* 逃逸分析减轻了GC压力，提高程序的运行速度
* 栈上内存使用完毕不需要GC处理，堆上内存使用完毕会交给GC处理
* 函数传参时对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能
* 根据代码具体分析，尽量减少逃逸代码，减轻GC压力，提高性能
