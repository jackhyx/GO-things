

### 读写锁简介
* 互斥锁我们都知道会锁定代码临界区，当有一个goroutine获取了互斥锁后，任何goroutine都不可以获取互斥锁，
* 只能等待这个goroutine将互斥锁释放，无论读写操作都会加上一把大锁，在读多写少场景效率会很低，

所以大佬们就设计出了读写锁，读写锁顾名思义是一把锁分为两部分：
读锁和写锁，读锁允许多个线程同时获得，因为读操作本身是线程安全的，
而写锁则是互斥锁，不允许多个线程同时获得写锁，并且写操作和读操作也是互斥的
总结来说：读读不互斥，读写互斥，写写互斥；

#### 总结
读写锁提供四种操作：读上锁，读解锁，写上锁，写解锁；加锁规则是读读共享，写写互斥，读写互斥，写读互斥；

* 读写锁中的读锁是一定要存在的，其目的是也是为了规避原子性问题，只有写锁没有读锁的情况下会导致我们读取到中间值；

Go语言的读写锁在设计上也避免了写锁饥饿的问题，通过字段readerCount、readerWait进行控制，
当写锁的goroutine被阻塞时，后面进来想要获取读锁的goroutine也都会被阻塞住，
当写锁释放时，会将后面的读操作goroutine、写操作的goroutine都唤醒，剩下的交给他们竞争吧；

#### 读锁获取锁流程：

* 锁空闲时，读锁可以立马被获取
* 如果当前有写锁正在阻塞，那么想要获取读锁的goroutine就会被休眠

#### 释放读锁流程：

* 当前没有异常场景或写锁阻塞等待出现的话，则直接释放读锁成功
* 若没有加读锁就释放读锁则抛出异常；
* 写锁被读锁阻塞等待的场景下，会将readerWait的值进行递减，readerWait表示阻塞写操作goroutine的读操作goroutine数量，当readerWait减到0时则可以唤醒被阻塞写操作的goroutine了；

#### 写锁获取锁流程

* 写锁复用了mutex互斥锁的能力，首先尝试获取互斥锁，获取互斥锁失败就会进入自旋/休眠；
* 获取互斥锁成功并不代表写锁加锁成功，此时如果还有占用读锁的goroutine，那么就会阻塞住，否则就会加写锁成功

#### 释放写锁流程

* 释放写锁会将负值的readerCount变成正值，解除对读锁的互斥
* 唤醒当前阻塞住的所有读锁
* 释放互斥锁
