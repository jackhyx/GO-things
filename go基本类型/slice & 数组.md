### 数组

#### 数组初始化
* [...]的用法
aa := [...]int{0, 1, 2, 3, 4, 5, 6, 7} //[...]根据初始值自动判断数组的长度
  fmt.Println(aa)
* 根据索引初始化 指定索引对应的值，未指定索引的值会用默认值填充，比如：0、false、""
  a3 := [5]int{0: 1, 4: 2} //根据索引初始化
  fmt.Println(a3) // [1 0 0 0 2]
#### 数组特点：值类型 不是引用类型
#### 数组的两个劣势 

* 固定的长度，这意味着初始化 array 后，不能再 push 超过 len(array) 长度的元素；array 作为参数在函数之间传递时，具有很大的性能浪费

* 因为 golang 中函数之间的调用不存在引用传递，都是值传递的。所以使用 array 作为参数时，意味着在调用函数时需要 copy 下这个参数， 这样会造成性能浪费。

#### slice 的实现
slice 底层的数据结构是一个结构体，包括三个元素
type slice struct {
array unsafe.Pointer // 是指向一个数组的指针
len int
cap int
}
#### 初始化一个 slice
直接声明: 比如 var s []int
使用 make 关键字，比如: s := make([]int, 0)
直接声明 slice 的方式内部是不申请内存空间的，slice 内部 array 指针指向 null。
使用 make 关键字会申请包含 0 个元素的内存空间，底层 array 指针指向申请的内存。


* 切片的本质是操作数组，只是数组是固定长度的，而切片的长度可变的
* 切片是引用类型，可以理解为引用数组的一个片段；而数组是值类型，把数组A赋值给数组B，会为数组B开辟新的内存空间，修改数组B的值并不会影响数组A。而切片作为引用类型，指向同一个内存地址，是会互相影响的。

#### 切片的长度和容量
* 切片的长度很好理解，就是元素的个数
* 切片的容量我们重点理解一下：在切片引用的底层数组中从切片的第一个元素到数组最后一个元素的长度（元素数量）

#### 切片的遍历 
```
s3 := make([]int, 3, 3)
s3 = []int{1, 2, 3}

for i := 0; i < len(s3); i++ {
fmt.Println(s3[i])
}

for i, v := range s3 {
fmt.Println(i, v)
}
```


####  追加多个元素
* append的第二个参数，我们传入了一个切片，需要在切片后写死...，表示将切片切割，将切片的值作为追加到第一个参数中的元素。
```
s1 := []string{"北京", "上海", "大连", "佛山"}
s3 := []string{"太原","石家庄"}
var s4 []string
s4 = append(s1,s3...) // ...表示拆开，将切片的值作为追加的元素
fmt.Printf("s4的值：%v",s4)
```

#### 复制切片
```
//定义切片s1
s1 := []int{1, 2, 3}

//第一种方式：直接声明变量 用=赋值
//s2切片和s1引用同一个内存地址
var s2 = s1

//第二种方式：copy
var s3 = make([]int, 3)
copy(s3, s1)            //使用copy函数将 参数2的元素复制到参数1
fmt.Println(s1, s2, s3) //都是[1 2 3]


```

#### 删除元素
* 注意：删除切片中的元素 不能直接删除 可以组合使用分割+append的方式删除切片中的元素
举个栗子：比如切除s3中的元素2(下标为1的元素)
s3 := []int{1, 2, 3}
s3 = append(s3[:1], s3[2:]...) //第一个不用拆开 原因是一个作为被接受的一方  是把后面的元素追加到第一个
fmt.Println(s3)
