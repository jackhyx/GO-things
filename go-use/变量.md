### 名称
* **如果一个实体在函数中声明，它只在函数局部有效。**
* **如果声明在函数外，它将对包里边的所有源文件可见。**
* **实体第一个字母的大小写决定其可见性是否跨包。**
* 如果名称以大写字母开头，意味着它对包外是可见和可访问的，可以被自己包之外的其它程序所引用，像fmt包的Printf函数。包名本身总是由小写字母组成
* 名称本身没有长度限制，但是Go的编程风格倾向于使用短名称，特别是作用域较小的局部变量。**通常，名称的作用域越大，就使用越长且更有意义的名**

### 声明
* **包级别的实体名字不仅对于包含其声明的源文件可见，而且对同一个包里边的所有源文件都可见。**
* 另一方面，局部声明仅仅是在声明所在的函数内可见，并且可能对于函数中的一小块区域可见 
* 函数的声明包含一个名字、一个参数列表（由函数的调用者提供的变量）、一个可选的返回值列表，以及函数体（其中包含具体的函数语句）。
* 如果函数不返回任何内容，返回值列表可以省略 

### 变量
* var声明创建一个具体类型的变量，然后给它附加一个名字，设置它的初始值。每一个声明有一个通用的形式
```var name type = expression```


类型和表达式部分可以省略一个，但是不能都省略。如果类型省略，则它的类型将由初始化表达式决定。如果表达式省略，其初始值对应于类型的零值。
对于数字，零值是0，对于布尔值是false;
对于字符串是""，对于接口和引用类型（slice、指针、map、通道、函数）是nil;
对于一个像数组或结构图这样的复合类型，零值是其所有元素或成员的零值
```
var s string
fmt.Printfln(s)//""   上例中会输出一个空字符串，而不是一些错误或不可预料的行为
```

* 可以声明一个变量列表，并选择使用对应的表达列表对其初始化
```
var i,j,k int //int,int,int
var b,f,s = true,2.3,"four"//bool,float64,string
```

* 初始值设定可以是字面量值或任意表达式。包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行。变量还可以通过调用返回多个值的函数进行初始化
```
var f,err = os.Open(name)//os.Open返回一个文件和一个错误
```

### 短变量声明
* 在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。形式如下
```
name := expression//name的类型由expression的类型决定

a := 1
b := 2.3
c := true
d := "abcd"
```
* 因其短小灵活，因此在局部变量的声明和初始化中主要使用这种短声明。var声明通常是为那些跟初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况
```
i := 100//int 类型
var boiling float64 = 100//float64类型

var names []string
var err error
var p Point
```
* 与var声明一样，多个变量可以以短变量声明的方式声明和初始化
```
i,j := 1,2
```
* 只有当他们对于可读性有帮助的时候才使用多个初始化表达式来进行变量声明，例如短小且天然一组的for循环的初始化。 :=是声明、而=是赋值。一个多变量的声明，不能和多重赋值（后边会介绍多重赋值）搞混，后者将右边的值赋给左边的对应变量
```
i,j = j,i//交换i和j的值（多重赋值）
```
* 与普通的var声明类似，短变量声明也可以用来调用像os.Open那样返回两个或多个值的函数
```
f,err := os.Open(name)
if err != nil {
return err
}
......
f.Close()
```
* 说明：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明（后边会介绍），那么对于那些变量，短声明的行为等同于赋值。看例子
```
in, err := os.Open(infile)
......
out,err := os.Create(outfile)
```
* 第一条语句声明了in和err，第二条语句仅声明了out，但向已有的err赋了值
* 短变量声明最少声明一个新变量，否则，代码编译将无法通过
```
f, err := os.Open(infile)
......
f,err := os.Create(outfile)//编译错误，没有新的变量被声明
```

### 格式化输出
**常见输出方式**

* Print：输出到控制台(不接受任何格式化，它等价于对每一个操作数都应用 %v)
* Println：输出到控制台并换行
* Printf：只可以打印出格式化的字符串。只可以直接输出字符串类型的变量（不可以输出整形变量和整形 等）
* Sprintf：格式化并返回一个字符串而不带任何输出
* Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout


### 多重赋值
* 另一种赋值方式是多重赋值，它允许几个变量一次性被赋值。当变量同时出现在赋值符两侧的时候，这种形式特别有用，例如，当交换两个变量的值时：
```
x, y = y, x
a[i], a[j] = a[j], a[i]

或者计算两个整数的最大公约数
func gcd(x,y int) int{
    for y!=0 {
        x,y = y, x%y
    }
    return x
}

或者计算斐波那契数列的第n个数
func fib(n int) int {
    x, y := 0, 1
    for i:=0; i < n; i++ {
        x, y = y, x+y
    }

    return x
}

```
* 但是如果表达式比较复杂，则应该避免使用这种多重赋值，一系列独立的语句更易读一些。
* 比如有些类型的表达式可能会产生多个值（比如调用了返回多个值的函数）。当在一个赋值语句中使用这样的调用时，左边的变量个数需要和函数的返回值一样多
```
f, err = os.Open("foo.txt")//函数调用返回两个值

```
* 通常函数使用额外的返回值来指示一些错误情况，例如通过os.Open()返回的error类型，或者一个通常叫ok的bool类型变量
```
v, ok = m[key] //map查询
v, ok = x.(T)//类型断言
v, ok = <=ch//通道接收

像声明变量一样，可以将不需要的值赋给空标识符
_, err = io.Copy(dst, src)
_, ok  = x.(T)
```

### 作用域
* 声明将名字和程序实体关联起来，如一个函数或一个变量。
* 声明的作用域是指用到声明时所声明名字的代码段。不要将作用域和生命周期混淆。
* 声明的作用域是声明在程序文本中出现的区域，它是一个编译时属性。
* 变量的生命周期是变量在程序执行期间能被程序的其他部分所引用的起止时间，它是一个运行时属性

* **语法块** :语法块（block）是由大括号围起来的一个语句序列，比如一个循环体或函数体。在语法块内部声明的变量对块外部不可见。块把声明包围起来，并决定了它的可见性
* **词法块**:将块的概念推广到其它没有显式包含在大括号中的声明代码，将其统称为词法块。包含了全部源代码的词法块，叫做全局块
* 每一个包、每一个文件、每一个for、if和switch语句，以及switch和select语句中的每一个条件，都是写在词法块里的。显式的写在大括号里的代码块也算是词法块
* 一个声明的词法块决定了声明的作用域的大小。像int、len和true等内置类型、函数或常量在全局快中声明，对整个程序可见。在包级别的声明，可以被同一个包里的任何文件引用。导入的包是文件级别的，所以他们可以在同一个文件内引用，但是不能在没有另一个import语句的前提下被同一个包中的其它文件中的东西引用。许多声明是局部的，仅可以在同一个函数中或者仅仅是函数的一部分所引用
* 控制流标签（break、continue和goto使用的标签）的作用域是整个外层的函数。**一个程序可以包含多个同名的声明，前提是他们在不同的词法块中。**
**当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局快寻找其声明。如果没有找到，它会报“undeclared name”错误，如果在内层和外层块都存在这个声明，内层的将先被找到。这种情况下，内层声明将覆盖外部声明，使它不可访问**
```
func f() {}

var g = "g"
func main() {
f := "f"
fmt.Println(f)//"f" 局部变量f覆盖了包级别函数f
fmt.Println(g)//"g" 包级变量
fmt.Println(h)//编译错误，未定义
}

```
### 示例
* 在函数中，词法块可能嵌套的很深，所以一个局部变量声明可能覆盖另一个。很多词法块使用if语句和for循环这类控制流结构构件。下边的示例中，有三个称为x的不同变量声明，因为他们每个声明都出现在不同的词法块中
```
func main() {
x := "hello!"
for i := 0; i< len(x); i++ {
x := x[i]
if x != '!' {
x := x + 'A' - 'a'
fmt.Printf("%c", x)//HELLO (每次迭代一个字母)
}
}
}
```
* 上边也提到过，不是所有的词法块都对应于显式大括号包围的语句序列，有一些词法块是隐式的。**for循环创建了两个词法块：一个是循环体本身的显式块，以及一个隐式块，它包含了一个闭合结构，其中就有初始化语句中声明的变量，如变量i。隐式块中声明的变量的作用域包括条件、后置语句（i++），以及for语句体本身**
* 下边这个例子中，也有三个名为x的变量，每一个都在不同的词法块中声明：一个在函数体中，一个在for语句块中，一个在循环体中。但只有两个块是显式的：
```
func main() {
x := "hello"
for _, x := range x {
x := x + 'A' - 'a'
fmt.Printf("%c", x)//HELLO (每次迭代一个字母)
}
}
```
* 像for循环一样，除了本身的主体块以外，if和switch语句还会创建隐式的词法块。下例中的if-else链展示x和y的作用域
```
if x := f();x==0 {
fmt.Println(x)
} else if y := g(x); x == y {
fmt.Println(x, y)
} else {
fmt.Println(x, y)
}
fmt.Println(x, y) //编译错误，x和y在这里不可见
```

* 第二个if语句嵌套在第一个中，所以第一个语句的初始化部分声明的变量在第二个语句中是可见的。同样的规则可以应用于switch语句：条件对应一个块，每一个case语句体对应一个块
```
if f, err := os.Open(fname); err != nil {//编译错误，f未使用
return err
}
f.Stat() //编译错误，f未定义
f.Close()//编译错误，f未定义
```
* f的作用域是if语句，所以f不能被接下来的语句访问，编译器会报错（根据编译器的不同，也肯能收到其他的报错：局部变量f没有被使用（在Go语言中，如果一个变量被定义了，却没有使用，是编译不通过的））
* 对于以上这种情况，通常是在条件判断之前，声明f，使其在if条件语句之后可以访问
```
f, err := os.Open(fname)
if err != nil {
return err
}
f.Stat()
f.Close()

或者

if f, err := os.Open(fname); err != nil {
return err
} else {
f.Stat()
f.Close()
}
```
* 通常Go的做法是在if块中处理错误，然后返回，这样成功执行的路径不会被变得支离破碎



### 变量的生命周期
* 生命周期指在程序执行过程中变量存在的时间段。包级别变量的生命周期是整个程序的执行时间。相反，局部变量有一个动态的生命周期：每次执行声明语句时创建一个新的实体，变量一直存在到它不可访问，这时它占用的存储空间会被回收。函数的参数和返回值也是局部变量，它们在函数被调用的时候创建
```
for t := 0.0; t < cycles*2*math.Pi; t+=res {
x := math.Sin(t)
y := math.Sin(t*freq + phase)
img.SetColorindex(size+int(x*size+0.5), size + int(y*size+0.5), blackIndex)
}
```
* 变量t在每次for循环的开始创建，变量x和y在循环的每次迭代中创建

* 那么垃圾回收器如何知道一个变量是否应该被回收？说来话长，基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯该变量的路径的源头，通过指针和其它方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其它的计算过程
* ***因为变量的生命周期是通过它是否可达来确定的*，所以局部变量可以在包含它的循环的一次迭代之外继续存活。即使包含它的循环已经返回，它的存在还可能延续**
* 编译器可以选择使用堆或栈上的空间来分配，这个选择不是基于使用var或new关键字来声明变量;
```
var global *int

func f() {
var x int
x = 1
global = &x
}

func g() {
y := new(int)
*y = 1
}
```
* 这里x一定是使用堆空间。
* 因为它在f函数返回以后还可以通过global变量访问，尽管它被声明为一个局部变量。这种情况可以说成是x从f中逃逸。当g函数返回时，变量y变得不可访问，可回收。因为y没有从g中逃逸，所以编译器可以安全的在栈上分配*y的空间，即便使用的new函数创建它。
* 在任何情况下，逃逸的概念使你不需要额外费心来写正确的代码，但要记住它在性能优化的时候是有好处的，因为每一次变量逃逸都需要一次额外的内存分配过程
* 垃圾回收对于写出正确的程序有巨大的帮助，但是免不了考虑内存的负担。不需要显式分配和释放内存，但是变量的生命周期是写出高效程序所必须清楚的。
* **比如，在长生命周期对象中保持短生命周期对象不必要的指针，特别是在全局变量中，会阻止垃圾回收器回收短生命周期的对象空间**

